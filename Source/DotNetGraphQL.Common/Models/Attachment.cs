using DotNetGraphQL.Common.Enums;
using System;

namespace DotNetGraphQL.Common.Models
{
    ///<summary>
    ///  Contact information for object support.
    ///</summary>
    public class Contact
    {
        ///$Identity of organization or person. Refer to: Structure: /Identity
        public Identity Identity { get; } = new Identity();
        ///The URL pointing to the contact information.
        public String URL { get; } = string.Empty;
        ///The email address of the contact person/organization.
        public String EMail { get; } = string.Empty;
    }


    ///<summary>
    ///  Entity encapsulating the details of an error. This allows the recipient to know details about the error and what may have caused the error.
    ///</summary>
    public class Error
    {
        ///Error code. 
        public String Code { get; } = string.Empty;
        ///$Severity specified how severe error in current execution path.  Refer to: Enum: /Severity/v1
        public Severity Severity { get; } = Severity.ERROR;
        ///Error text. When error return text will be formate, based on text string, properties and language.
        public String Text { get; } = string.Empty;
        ///Error description contains detailed information about error. 
        public String Description { get; } = string.Empty;
        ///$Properties allow to parametrize error name. Name can use @number or @name specification to reference different parameters from parameter list by ordinal number or by parameter name. Refer to: Structure[]: /Property/v1
        public Property[] Properties { get; } = new Property[0];
        ///URI to object or entity error associated with.
        public String Entity { get; } = string.Empty;
        ///Name of the field error associated with.
        public String Field { get; } = string.Empty;
    }


    ///<summary>
    ///  Structure for object history. Object history provides information when object was updated and in what completion state it is now.
    ///</summary>
    public class History
    {
        ///Date of object creation.
        public DateTime Created { get; } = DateTime.Now;
        ///User created object.
        public String CreatedBy { get; } = string.Empty;
        ///Date of object last update.
        public DateTime Updated { get; } = DateTime.Now;
        ///User last updated object.
        public String UpdatedBy { get; } = string.Empty;
        ///Mote about goal of object update.
        public String UpdateNote { get; } = string.Empty;
        ///Message in issue associated with changes in object.
        public String UpdateMessage { get; } = string.Empty;
        ///Date object was mirrored into GitHub.
        public DateTime Mirrored { get; } = DateTime.Now;
        ///Date object was retired.
        public DateTime Retired { get; } = DateTime.Now;
        ///User retired object.
        public String RetiredBy { get; } = string.Empty;
        ///$Array of completion statuses reached by this object. Refer to: Structure[]: Completion/v1
        public Completion[] Completions { get; } = new Completion[0];
        ///Date of object creation.
        public DateTime CreatedAt { get; } = DateTime.Now;
        ///Date of object last update. This is important value as it is flag for optimistic commit to detect overriding changes. 
        public DateTime UpdatedAt { get; } = DateTime.Now;
        ///Mote about goal of object update.
        public String UpdatedNote { get; } = string.Empty;
        ///Message in issue associated with changes in object.
        public String UpdatedMessage { get; } = string.Empty;
        ///Date object last update was reviewed by owner. This is indicates user see and aknowalage change.
        public DateTime ReviewedAt { get; } = DateTime.Now;
        ///User who reviewed and acknowledge the last update changes.
        public String ReviewedBy { get; } = string.Empty;
        ///Date object was retired.
        public DateTime RetiredAt { get; } = DateTime.MinValue;
    }

    ///<summary>
    ///  Identity of object in DifHub. Objects can be identify by globaly unique Id and localy unique name.
    ///</summary>
    public class Identity
    {
        ///Id of the object. It is global unique identificator, optional for minor objects and required for major objects. When object created Id will be generated by backend service.
        public Guid Id { get; } = Guid.NewGuid();
        ///Name of the object. It is textual object identificator, need to be unique inside folder of the object.
        public String Name { get; } = string.Empty;
        ///Description for the object functionality. It is text with specification of object and way it used in application.
        public String Description { get; } = string.Empty;
        ///$Translations for the object name, description to different languages. Object can contains as many translations as required by application. Refer to: Structure[]: /Translation/v1
        public Translation[] Translations { get; } = new Translation[0];
    }

    ///<summary>
    ///  Property of object. Property presented as Name/Value pair.
    ///</summary>
    public class Property
    {
        ///$Identity of the property. Refer to: Structure: /Identity
        public Identity Identity { get; } = new Identity();
        ///$Type of the property data. Refer to: Enum: /Type
        public String Type { get; } = string.Empty;
        ///Reference to structure for types of structure, field or enum. 
        ///Reference can be complete and include organization name, system name, application name and dataset name. 
        ///Reference can be short and contain only dataset name. Version identify structure currently
        ///used and if not specified, it means last approved version.
        public String Reference { get; } = string.Empty;
        ///Property value.
        public String Value { get; } = string.Empty;
    }


    ///<summary>
    ///  Schedule for activity base on cron expression.
    ///</summary>
    public class Schedule
    {
        ///Cron expression to define time of execution. Expression represent text specification for execution time. 
        public String Expression { get; } = string.Empty;
        ///$Specifications for points in time of execution. Refer to: Structure[]: /TimeSpec/v1
        public TimeSpec[] Specifications { get; } = new TimeSpec[0];
    }


    ///<summary>
    ///  Factor for time specification. Factor apply to current time components before compare with specification. For example for day 05/09/2017 is a day 9 of May. With factor 2 for Daily, we will divide it to 2 and compare remains to Month Day spec. If our spec defines execute on first day of month, and factor is 2, we will execute every second day of month.
    ///</summary>
    public class TimeFactor
    {
        ///$Component of date factor apply to. Refer to: Enum: /Frequency/v1
        public Frequency Component { get; } = Frequency.DAILY;
        ///Value of factor to apply.
        public short Value { get; } = 0;
    }


    ///<summary>
    ///  Time specification defines reacquiring point in time, when some operation can be executed. Time spec validated against date-time of some moment in time. If moment match specification operation can be executed. Validation happens per every component of specification. Factor applied to component before validation. 
    ///    For example: 
    /// 1. Month-05 means we execute in first hour of first day of May.
    /// 2. Hour 00 means we execute on first hour of every day.
    /// 3.Minute 3 means we execute every third minutes of the hour
    /// 4. Hour 01, Minute 01 - we execute every day in first hour and first minute.
    ///</summary>
    public class TimeSpec
    {
        ///$Specification of month in which bill need to be produced. Refer to: Enum: /Month/v1
        public Month Month { get; } = Month.JANUARY;
        ///$Specification for week. Refer to: Enum: /Week/v1
        public Week Week { get; } = Week.W01;
        ///$Specification for month day bill need to be produced. Refer to: Enum: /MonthDay/v1
        public MonthDay Day { get; } = MonthDay.D01;
        ///$Specification for week day on which bill need to be produced. Refer to: Enum: /WeekDay/v1
        public WeekDay WeekDay { get; } = WeekDay.FRIDAY;
        ///$Specification cat off time of day for bill production. Refer to: Enum: /Hour/v1
        public Hour Hour { get; } = Hour.H00;
        ///Minute we use to execute. It is number from 0 to 50.
        public ushort Minute { get; } = 0;
        ///$This is factors used to modify portion of current date for validation with spec.   Refer to: Structure[]: /TimeFactor/v1
        public TimeFactor[] Factors { get; } = new TimeFactor[0];
    }


    ///<summary>
    ///  Translation for object identity to specific language. Translation can contains information for value of object specific to language it represents.
    ///</summary>
    public class Translation
    {
        ///$Locale for language translation defined for. Refer to: Enum: /Locale/v1
        public Locale Locale { get; } = Locale.EN_US;
        ///Translation for object name.
        public String Name { get; } = string.Empty;
        ///Translation for object description.
        public String Description { get; } = string.Empty;
        ///Value specific to translation locale for objects with value.
        public String Value { get; } = string.Empty;
    }


    ///<summary>
    ///  Structure to maintain value of specific type.
    ///</summary>
    public class Variant
    {
        ///$Type of value variant contains. Refer to: Enum: /Type/v1
        public string Type { get; } = string.Empty;
        ///Value of type variant maintained.
        public String Value { get; } = string.Empty;
    }

    ///<summary>
    ///  Agreement is a container for all agreement documents.
    ///</summary>
    public class Agreement
    {
        ///$Identity of documents contain globally unique id. Refer to: Structure: /Identity/v1
        public Identity? Identity { get; }
        ///$Document is a resource and will be accessible through API. Refer to: Structure: Entity/v1
        public Entity Entity { get; } = new Entity();
        ///$Parties participating in agreement. Refer to: Structure[]: AgreementParty/v1
        public AgreementParty[] Parties { get; } = new AgreementParty[0];
    }


    ///<summary>
    ///  Contact of agreement Party. Contact reference to party contact by type or id.
    ///</summary>
    public class AgreementContact
    {
        ///Identity of agreement party contact must be unique inside agreement. party
        public Guid Id { get; } = Guid.NewGuid();
        ///$Management information for object. Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///$Role of contact in agreement. Refer to: Enum: ContactRole/v1
        public ContactRole Role { get; } = ContactRole.APPROVER;
        ///$Type of contact from list of contact of the party. Refer to: Enum: ContactType/v1
        public ContactType Type { get; } = ContactType.ATTORNEY;
        ///Id of the contact in the list of party contacts. This is optional if specific contact assigned to role in agreement.
        public Guid ContactId { get; } = Guid.NewGuid();
    }


    ///<summary>
    ///  Party of agreement. Party is reference to party resource.
    ///</summary>
    public class AgreementParty
    {
        ///Identity of agreement party must be unique inside agreement.
        public Guid Id { get; } = Guid.NewGuid();
        ///$Management information for action Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///Role of the party in agreement. Roles defined by agreement creator. Role must be unique for party inside agreement.
        public String Role { get; } = string.Empty;
        ///Party to reference for agreement participation.
        public Party Party { get; } = new Party();
        ///$List of contacts to work on party agreement. Refer to: Structure[]: AgreementContact/v1
        public AgreementContact[] Contacts { get; } = new AgreementContact[0];
    }


    ///<summary>
    ///  Contact information for party.
    ///</summary>
    public class ContactInfo
    {
        ///Identity of contact must be unique inside party.
        public Guid Id { get; } = Guid.NewGuid();
        ///$Management information for action Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///$Type of contact for party. Refer to: Enum: ContactType/v1
        public ContactType Type { get; } = ContactType.ATTORNEY;
        ///Contact name
        public String Name { get; } = string.Empty;
        ///Phone number for contact.
        public String Phone { get; } = string.Empty;
    }


    ///<summary>
    ///  Document of agreement. Document build on top of template by providing required configuration properties. Data can be specified on level of clauses or on level of template.
    ///</summary>
    public class Document
    {
        ///$Identity of documents contain globally unique id. Refer to: Structure: /Identity/v1
        public Identity Identity { get; } = new Identity();
        ///$Document is a resource and will be accessible through API. Refer to: Structure: Entity/v1
        public Entity Entity { get; } = new Entity();
        ///$Document will have versions, as it will be evolving. Refer to: Structure: /Version/v1
        public Version Version { get; } = new Version();
        ///List of parties participating in document from list of parties of agreement, Here is refereence by role of the party in agreement.
        public String[] Parties { get; } = new String[0];
        ///$List of components document assembled from.  Refer to: Structure[]: Component/v1
        public Component[] Components { get; } = new Component[0];
        ///Unique identifier of the document.
        public String Id { get; } = string.Empty;
        ///Identifier for the document across versions. The Id of each document version differs for each version. The documentID remains the same for each version.
        public String DocumentId { get; } = string.Empty;
        ///The template used to create the document.
        public String TemplateId { get; } = string.Empty;
        /// name
        public String Name { get; } = string.Empty;
        ///$ Refer to: Enum: 
        public string Type { get; } = String.Empty;
        ///The complete json data set that, with the template, populates the document contents.
        public String Dataset { get; } = string.Empty;
        /// created date
        public DateTime CreatedDate { get; } = DateTime.MinValue;
        /// id of created by person
        public String CreatedById { get; } = string.Empty;
        /// id of the last updated person
        public String LastUpdatedById { get; } = string.Empty;
        ///$Management information for document Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///Educational material document identifier
        public String DocumentType { get; } = string.Empty;
        ///Educational material reference pointer
        public String Reference { get; } = string.Empty;
        ///Educational material publication date
        public DateTime PublicationDate { get; } = DateTime.MinValue;
    }

    ///<summary>
    ///  Party represents partner account. Agreement can be created between multiple external parties and organizations of current account.
    ///</summary>
    public class Party
    {
        ///$Identity of parties contain globally unique id. Refer to: Structure: /Identity/v1
        public Identity Identity { get; } = new Identity();
        ///$Party is a resource and will be accessible through API. Refer to: Structure: Entity/v1
        public Entity Entity { get; } = new Entity();
        ///$List of contacts used for party. Refer to: Structure[]: Contact/v1
        public Contact[] Contacts { get; } = new Contact[0];
        ///Identifier of Organization associated with an agreement document.
        public String OrganizationID { get; } = string.Empty;
        ///Identifies the person associated with the agreement
        public String PersonId { get; } = string.Empty;
        ///The address used by the party for the associated agreement document.
        public String AddressId { get; } = string.Empty;
        ///$Indicates whether the party is an individual, organization, or a representative. Refer to: Enum: PartyType/v1
        public PartyType PartyType { get; } = PartyType.INDIVIDUAL;
    }

    ///<summary>
    ///  Attribute of the schema
    ///</summary>
    public class Attribute
    {
        ///$Identity of the attribute. Refer to: Structure: /Identity
        public Identity Identity { get; } = new Identity();
        ///Position of attribute  in the list. 
        public int Ordinal { get; } = 0;
        ///Number of value for attribute. By default it is one, it means attribute is single value. When count set to 0, it is array of values of undefined size. All other numbers defines fixed size for array.
        public uint Count { get; } = 0;
        ///$Type of attributes. Let's use system types for now. Refer to: Enum: /Type/v1
        public String Type { get; } = string.Empty;
        ///Reference is URI of other schema.
        public Schema Reference { get; } = new Schema();
        ///Default value for attribute.
        public String Default { get; } = string.Empty;
        ///Format for attribute value. Default value must be presented in specified format.
        public String Format { get; } = string.Empty;
    }


    ///<summary>
    ///  Specification of clause component in catalog. Clause contains specification for schema and rendering.
    ///</summary>
    public class Clause
    {
        ///$Clause have globally unique id. Refer to: Structure: /Identity/v1
        public Identity Identity { get; } = new Identity();
        ///$Clause will have versions, as it will be evolving. Refer to: Structure: /Version/v1
        public Version Version { get; } = new Version();
        ///$Clause is a resource and will be accessible through API.  Refer to: Structure: Entity/v1
        public Entity Entity { get; } = new Entity();
        ///List of parties recognized by clause. Party presented by name. Name of party used to identify party obligations.
        public String[] Parties { get; } = new string[0];
        ///$Clause list of attributes, which defines clause schema. Refer to: Structure[]: Attribute/v1
        public Attribute[] Attributes { get; } = new Attribute[0];
        ///$List of events supported by clause. Refer to: Structure[]: Event/v1
        public Event[] Events { get; } = new Event[0];
    }


    ///<summary>
    ///  Obligation for one of clause's party. Obligation will be activated on event and provide information associated with it. 
    ///</summary>
    public class ClauseObligation
    {
        ///Identity of obligation inside clause event..
        public Guid Id { get; } = Guid.Empty;
        ///$Management information for clause obligation Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///Name of clause party associated with obligation.
        public String Party { get; } = string.Empty;
        ///Reference to obligation defined in catalog.
        public Obligation Obligations { get; } = new Obligation();
    }


    ///<summary>
    ///  View Element. Element represent visual component of view.
    ///</summary>
    public class Element
    {
        ///$Identity of view element. Refer to: Structure: /Identity/v1
        public Identity Identity { get; } = new Identity();
        ///Order define position for element in view. Elements can have different order from sequence of specification. If order define as 0 it same as sequence number of specification.
        public uint Order { get; } = 0;
        ///Reference to parent element. Parent define frame this element included in.
        public Identity Parent { get; } = new Identity();
        ///$Visability property defines if it visual or hidden. Refer to: Enum: EventType/v1
        public EventType Visibility { get; } = EventType.CUSTOM;
        ///$Frame of element. Frame define rectangular view for element visual components. Refer to: Structure: Clause/v1
        public Clause Frame { get; } = new Clause();
        ///$Style of element. Style define attributes of element visual components. Refer to: Structure: Clause/v1
        public Clause Style { get; } = new Clause();
        ///$Image of element visual component. Refer to: Structure: Attribute/v1
        public Attribute Image { get; } = new Attribute();
        ///Text of element visual component.
        public String Text { get; } = string.Empty;
        ///$Alignment of text in element content frame. Refer to: Enum: EventType/v1
        public EventType Align { get; } = EventType.CUSTOM;
        ///$Control of element. Control define configuration for visual compoments. Refer to: Structure: Clause/v1
        public Clause Control { get; } = new Clause();
    }


    ///<summary>
    ///  Event of the clause. Clause fire events when state controlled by clause changed.
    ///</summary>
    public class Event
    {
        ///$Identity of the event. Refer to: Structure: /Identity
        public Identity Identity { get; } = new Identity();
        ///Position of event in the list of events 
        public uint Ordinal { get; } = 0;
        ///$Type of event Refer to: Enum: EventType/v1
        public EventType Type { get; } = EventType.CUSTOM;
        ///$Event list of attributes. This is attributes event will provide when fired. Refer to: Structure[]: Attribute/v1
        public Attribute[] Attributes { get; } = new Attribute[0];
        ///$List of obligations activated by event. Refer to: Structure[]: ClauseObligation/v1
        public ClauseObligation[] Obligations { get; } = new ClauseObligation[0];
    }


    ///<summary>
    ///  Obligation defined by clause. Obligation will be fired when event associated with it fired up.
    ///</summary>
    public class Obligation
    {
        ///$Obligation have globally unique id. Refer to: Structure: /Identity/v1
        public Identity Identity { get; } = new Identity();
        ///$Clause will have versions, as it will be evolving. Refer to: Structure: /Version/v1
        public Version Version { get; } = new Version();
        ///$Schema is a resource and will be accessible through API.  Refer to: Structure: Entity/v1
        public Entity Entity { get; } = new Entity();
        ///$Attributes of the schema Refer to: Structure[]: Attribute/v1
        public Attribute[] Attributes { get; } = new Attribute[0];
    }


    ///<summary>
    ///  Schema for the clause data.
    ///</summary>
    public class Schema
    {
        ///$Shema have globally unique id. Refer to: Structure: /Identity/v1
        public Identity Identity { get; } = new Identity();
        ///$Clause will have versions, as it will be evolving. Refer to: Structure: /Version/v1
        public Version Version { get; } = new Version();
        ///$Schema is a resource and will be accessible through API.  Refer to: Structure: Entity/v1
        public Entity Entity { get; } = new Entity();
        ///$Attributes of the schema Refer to: Structure[]: Attribute/v1
        public Attribute[] Attributes { get; } = new Attribute[0];
    }


    ///<summary>
    ///  Event of the clause. Clause fire events when state controlled by clause changed.
    ///</summary>
    public class View
    {
        ///$Identity of the event. Refer to: Structure: /Identity
        public Identity Identity { get; } = new Identity();
        ///Position of event in the list of events 
        public int Ordinal { get; } = 0;
        ///$Type of view. Refer to: Enum: ViewType/v1
        public ViewType Type { get; } = ViewType.DOCUMENT;
        ///$Form factor of view. Refer to: Enum: ViewForm/v1
        public ViewForm Form { get; } = ViewForm.DESKTOP;
        ///$Type of event Refer to: Enum: /Locale/v1
        public Locale Language { get; } = Locale.EN_US;
        ///$View's list of elements. Elements define actual visual components of the view. Refer to: Structure[]: Element/v1
        public Element[] Elements { get; } = new Element[0];
    }


    ///<summary>
    ///  Component of template. Component can contain clause or other template.
    ///</summary>
    public class Action
    {
        ///Identity of action must be unique inside template.
        public Guid Id { get; } = Guid.Empty;
        ///$Management information for action Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///Component id in the template action defined for.
        public Guid Component { get; } = Guid.Empty;
        ///Event id in the component action defined for.
        public Guid Event { get; } = Guid.Empty;
        ///Obligation action to support.
        public Obligation Obligation { get; } = new Obligation();
        ///Workflow to execute for obligation support.
        public Identity Workflow { get; } = new Identity();
    }


    ///<summary>
    ///  Component of template. Component can contain clause or other template.
    ///</summary>
    public class Component
    {
        ///Identity of component must be unique inside template.
        public Guid Id { get; } = Guid.Empty;
        ///$Management information for component Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///$Type of component defines it use clause or other template. Refer to: Enum: ComponentType/v1
        public ComponentType Type { get; } = ComponentType.CLAUSE;
        ///$List of parties used in component. Refer to: Structure[]: ComponentParty/v1
        public ComponentParty[] Parties { get; } = new ComponentParty[0];
        ///$Reference to actual template or clause from catalog. Refer to: Structure: ComponentSpec/v1
        public ComponentSpec Specification { get; } = new ComponentSpec();
        ///Specification of values for clause or template attributes. Reference  to attributes of current template attributes can be used to configure clause or template.
        public String Dataset { get; } = string.Empty;
    }


    ///<summary>
    ///  Party of component of template. Party map template and document party to parties of clause or template in component..
    ///</summary>
    public class ComponentParty
    {
        ///Name of clause or template party inside component. This is party name specified in actual clause or template reference by component. 
        public String Id { get; } = string.Empty;
        ///$Management information for component party. Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///Reference to actual party of template or document by name of the party/.
        public String Party { get; } = string.Empty;
        ///Specification of values for the party as it presented in component on time of document creation..
        public String Dataset { get; } = string.Empty;
    }


    ///<summary>
    ///  Component of template. Component can contain clause or other template.
    ///</summary>
    public class ComponentSpec
    {
        ///Guid
        public String Id { get; } = string.Empty;
        ///$Reference to actual template from template catalog. Refer to: Structure: TemplateSpec/v1
        public TemplateSpec Template { get; } = new TemplateSpec();
        ///$Reference to actual clause from clause catalog. Refer to: Structure[2]: ClauseSpec/v1
        public ClauseSpec[] Clause { get; } = new ClauseSpec[0];
    }


    ///<summary>
    ///  Integration of template with enterprise internal and external systems. Template can have multiple integrations designed for different set of systems. When document created, integration relevant for party will be used.
    ///</summary>
    public class Integration
    {
        ///$Identity of integration contains globally unique id. Refer to: Structure: /Identity/v1
        public Identity Identity { get; } = new Identity();
        ///$Integration will have versions, as it will be evolving. Refer to: Structure: /Version/v1
        public Version Version { get; } = new Version();
        ///$Integration is a resource and will be accessible through API. Parent for Integration is a Template.   Refer to: Structure: Entity/v1
        public Entity Entity { get; } = new Entity();
        ///Party of template, integration is applicable for.
        public String Party { get; } = string.Empty;
        ///$List of attributes template required to specify for document. Refer to: Structure[]: Attribute/v1
        public Attribute[] Attributes { get; } = new Attribute[0];
        ///$List of actions implemented in template. Refer to: Structure[]: Action/v1
        public Action[] Actions { get; } = new Action[0];
    }


    ///<summary>
    ///  Template of agreement. Template specified prototype for agreements. Agreement documents use template to configure actual agreement. Template contains two main parts: attributes and components. Attributes provide specification of configuration parameters for template. Components defines smart clauses document will be assembled from.
    ///</summary>
    public class Template
    {
        ///$Identity of template contains globally unique id. Refer to: Structure: /Identity/v1
        public Identity Identity { get; } = new Identity();
        ///$Template will have versions, as it will be evolving. Refer to: Structure: /Version/v1
        public Version Version { get; } = new Version();
        ///$Template is a resource and will be accessible through API.  Refer to: Structure: Entity/v1
        public Entity Entity { get; } = new Entity();
        ///List of parties recognized by template. Party presented by name. Name of party used to identify party connection to templates clauses..
        public String[] Parties { get; } = new string[0];
        ///$List of attributes template required to specify for document. Refer to: Structure[]: Attribute/v1
        public Attribute[] Attributes { get; } = new Attribute[0];
        ///$List of components template assembled from.  Refer to: Structure[]: Component/v1
        public Component[] Components { get; } = new Component[0];
        ///Unique identifier for the template
        public String Id { get; } = string.Empty;
        ///
        public String Name { get; } = string.Empty;
    }

    public class Money
    {

    };

    ///<summary>
    ///  A amount of money. Money meagered by sum of currency.
    ///</summary>
    public class Amount
    {
        ///Amount of money
        public Money MoneyAmount { get; } = new Money();
        ///$Currency to represent amount of money.  Refer to: Enum: /Currency/v1
        public Currency Currency { get; } = Currency.AUD;
    }


    ///<summary>
    ///  A text note which also contains information about who made the statement and when. 
    /// http://build.fhir.org//datatypes.html#Attachment
    ///</summary>
    public class Annotation
    {
        ///This is id for note element. 
        public Guid Id { get; } = Guid.Empty;
        ///$This is header for note , containing information for record management. Refer to: Structure: Element/v1
        public Element Header { get; } = new Element();
        ///$Individual responsible for the annotation Refer to: Structure: Author/v1
        public Author Author { get; } = new Author();
        ///The annotation - text content (as markdown)
        public String Text { get; } = string.Empty;
    }


    ///<summary>
    ///  This type is for containing or referencing attachments - additional data content defined in other formats. The most common use of this type is to include images or reports in some report format such as PDF. However it can be used for any data that has a MIME type.
    /// http://build.fhir.org//datatypes.html#Attachment
    ///</summary>
    public class Attachment
    {
        ///Guid of the attachmentt
        public Guid Id { get; } = Guid.Empty;
        ///Mime type of the content, with charset etc.
        public String ContentType { get; } = string.Empty;
        ///$Human language of the content (BCP-47) Refer to: Enum: /Locale/v1
        public Locale Language { get; } = Locale.EN_US;
        ///Data inline, base64ed
        public String Data { get; } = string.Empty;
        ///Uri where the data can be found
        public String Url { get; } = string.Empty;
        ///Number of bytes of content (if url provided)
        public uint Size { get; } = 0;
        ///Hash of the data (sha-1, base64ed)
        public String Hash { get; } = string.Empty;
        ///Label to display in place of the data
        public String Title { get; } = string.Empty;
        ///Date attachment was first created
        public DateTime Creation { get; } = DateTime.MinValue;
        ///$This is id for period element. It is inherit properties from Element structure. Refer to: Structure: Element/v1
        public Element id { get; } = new Element();
    }


    ///<summary>
    ///  Author union which can provide different type of author reference for document.
    ///</summary>
    public class Author
    {
        ///Reference to author of the document registered in the system as entity.
        public Identity AuthorReference { get; } = new Identity();
        ///Text information about author not reference in the system.
        public String AuthorString { get; } = string.Empty;
    }


    ///<summary>
    ///  Binding represents connection of entity to entity in other external systems. It can be system where entity actually originated ond from which it was imported or system where entity exported. 
    ///</summary>
    public class Binding
    {
        ///$Binding identity in system it imported from or exported to. Id is globally unique. Name is unique binding name inside entity only. Refer to: Structure: /Identity
        public Identity Identity { get; } = new Identity();
        ///$Type of binding defines system we bind to. Refer to: Enum: BindingType/v1
        public BindingType Type { get; } = BindingType.ERP;
        ///Code of object in system we bind to if different from id.
        public String Code { get; } = string.Empty;
    }


    ///<summary>
    ///  Completion status for stage of execution like: finilization, aproval and so on.
    ///</summary>
    public class Completion
    {
        ///$Completion Status for some state of execution. Refer to: Enum: EntityState/v1
        public EntityState Status { get; } = EntityState.ACTIVE;
        ///Date of status acived and satge of activity completed.
        public DateTime CompletedAt { get; } = DateTime.Now;
        ///Person documented completion of this stage by user name.
        public String CompletedBy { get; } = string.Empty;
        ///Note provided by operator on completion.
        public String CompletedNote { get; } = string.Empty;
        ///This is link to message, which change status of the issue to specified by this completion.
        public String CompletedMessage { get; } = string.Empty;
    }

    ///<summary>
    ///  Duration union which can provide different type of time duration values.
    ///</summary>
    public class Duration
    {
        ///Duration as time span.
        public TimeSpan DurationTimespan { get; } = TimeSpan.Zero;
        ///$Duration as duration specification by units of time. Refer to: Structure: DurationSpec/v1
        public DurationSpec DurationTimeSpec { get; } = new DurationSpec();
        ///$Duration as period of time defined by specification Refer to: Structure: Period/v1
        public Period DurationPeriod { get; } = new Period();
        ///$Duration as period of time. Refer to: Structure: PeriodSpec/v1
        public PeriodSpec DurationPeriodSpec { get; } = new PeriodSpec();
        ///$Range of values for duration. Refer to: Structure: Range/v1
        public Range DurationRange { get; } = new Range();
        ///Id of Occurence
        public String Id { get; } = string.Empty;
    }


    ///<summary>
    ///  A time period defined by number of time units. 

    ///</summary>
    public class DurationSpec
    {
        ///Number of time units used for period.
        public float Value { get; } = 0;
        ///$Time units to define duration. Refer to: Enum: UnitsOfTime/v1
        public UnitsOfTime Units { get; } = UnitsOfTime.H;
    }

    ///<summary>
    ///  Updatable entity. Entity can be accessed by RESTful API and referenced.
    ///</summary>
    public class Entity
    {
        ///$Reference to id of folder for current entity. It include URI of parent entity in name. Refer to: Structure: /Identity
        public Identity Parent { get; } = new Identity();
        ///$Type of the entity. Refer to: Enum: EntityType/v1
        public EntityType Type { get; } = EntityType.ACCOUNT;
        ///$State of the entity Refer to: Enum: EntityState/v1
        public EntityState State { get; } = EntityState.ACTIVE;
        ///This entity record is in active use
        public Boolean Active { get; } = false;
        ///List of additional names for the entity.
        public String[] Alias { get; } = new string[0];
        ///$Source system originated the entity. If not specified entity instantiated by core system. Refer to: Enum: BindingType/v1
        public BindingType Source { get; } = BindingType.ERP;
        ///$Reference to entity system bind to. Refer to: Structure[]: Binding/v1
        public Binding[] Bindings { get; } = new Binding[0];
        ///$List of tags for entity association. Refer to: Structure[]: /Identity/v1
        public Identity[] Tags { get; } = new Identity[0];
        ///$Advince properties of the entity. It is name value pairs for additional user defined properties of the entity. Refer to: Structure[]: /Property/v1
        public Property[] Properties { get; } = new Property[0];
        ///$History of the entity instance. Refer to: Structure: History/v1
        public History History { get; } = new History();
    }


    ///<summary>
    ///  Link to a resource that associated with current resource.
    ///</summary>
    public class Link
    {
        ///$Element data inherited from element structure Refer to: Structure: Element/v1
        public String ElementId { get; } = string.Empty;
        ///$Extensions that cannot be ignored Refer to: Structure[]: Extension/v1
        ///Extension[] ModifierExtension { get; } = new Extension[0];
        /// The resource to which this resource is associated.
        public Identity Target { get; } = new Identity();
        ///$Identity assurance level for related objects Refer to: Enum: IdentityAssuranceLevel/v1
        ///IdentityAssuranceLevel Assurance { get; };
        ///$Type of the link. Refer to: Enum: LinkType/v1
        public LinkType Type { get; } = LinkType.REFER;
    }


    ///<summary>
    ///  Occurrence union which can provide different type of time values.
    ///</summary>
    public class Occurrence
    {
        ///$occurrence as period of time. Refer to: Structure: Period/v1
        public Period OccurrencePeriod { get; } = new Period();
        ///$Range of values for occurance. Refer to: Structure: Range/v1
        public Range OccuranceRange { get; } = new Range();
        ///Occurrence as point in time.
        public DateTime OccurrenceDateTime { get; } = DateTime.MaxValue;
        ///$Occurrence as point in time. Refer to: Structure: Timing/v1
        public Timing OccurrenceTiming { get; } = new Timing();
        ///Id of Occurence
        public String Id { get; } = string.Empty;
    }


    ///<summary>
    ///  A time period defined by a start and end date/time. 
    /// A period specifies a range of times. The context of use will specify whether the entire range applies (e.g. "the patient was an inpatient of the hospital for this time range") or one value from the period applies (e.g. "give to the patient between 2 and 4 pm on 24-Jun 2013"). This is simple period used not as part of array of elements.
    ///</summary>
    public class Period
    {
        ///Starting time with inclusive boundary
        public DateTime Start { get; } = DateTime.MaxValue;
        ///End time with inclusive boundary, if not ongoing.
        public DateTime End { get; } = DateTime.MinValue;
    }


    ///<summary>
    ///  Specification for time period. Specification used to define reacquiring period of time.
    ///</summary>
    public class PeriodSpec
    {
        ///First year of period specification.
        public short YearStart { get; } = 0;
        ///Last year of specified period.
        public short YearEnd { get; } = 0;
        ///$First month of the period. Refer to: Enum: /Month/v1
        public Month MonthStart { get; } = Month.JANUARY;
        ///$Last month of the period. Refer to: Enum: /Month/v1
        public Month MonthEnd { get; } = Month.JANUARY;
        ///$First day of month of the period. Refer to: Enum: /MonthDay/v1
        public MonthDay MonthDayStart { get; } = MonthDay.D01;
        ///$Last day of month of the period. Refer to: Enum: /MonthDay/v1
        public MonthDay MonthDayEnd { get; } = MonthDay.D01;
        ///$First week of the period. Refer to: Enum: /Week/v1
        public Week WeekStart { get; } = Week.W01;
        ///$Last week of the period. Refer to: Enum: /Week/v1
        public Week WeekEnd { get; } = Week.W01;
        ///$First day of week of the period. Refer to: Enum: /WeekDay/v1
        public WeekDay WeekDayStart { get; } = WeekDay.FRIDAY;
        ///$Last day of week of the period. Refer to: Enum: /WeekDay/v1
        public WeekDay WeekDayEnd { get; } = WeekDay.FRIDAY;
        ///Initial time of time period.
        public DateTime TimeStart { get; } = DateTime.MinValue;
        ///Final time of time period.
        public DateTime TimeEnd { get; } = DateTime.MinValue;
    }


    ///<summary>
    ///  The absolute geographic location.
    ///</summary>
    public class Position
    {
        ///Longitude with WGS84 datum
        public Double Longitude { get; } = 0;
        ///Latitude with WGS84 datum
        public Double Altitude { get; } = 0;
        ///Altitude with WGS84 datum
        public Double Latitude { get; } = 0;
    }


    ///<summary>
    ///  A amount of money to pay per quantity of service or product..
    ///</summary>
    public class Price
    {
        ///Guid of the price
        public Guid Id { get; } = Guid.Empty;
        ///$Amount of money to pay. Refer to: Structure: Amount/v1
        public Amount Amount { get; } = new Amount();
        ///$Quantity of service or product. By default it is one instance. Refer to: Structure: Quantity/v1
        public Quantity Quantity { get; } = new Quantity();
    }


    ///<summary>
    ///  A measured amount (or an amount that can potentially be measured). 
    ///</summary>
    public class Quantity
    {
        ///Numerical value (with implicit precision)
        public Decimal Value { get; } = Decimal.Zero;
        ///$How to understand the value Refer to: Enum: QuantityComparator/v1
        /// QuantityComparator Comparator { get; };
        ///Unit representation
        public String Unit { get; } = string.Empty;
        ///System that defines coded unit form
        public String System { get; } = string.Empty;
        ///Coded form of the unit
        public String Code { get; } = string.Empty;
        ///Id of the Quantity (Temporary field)
        public String Id { get; } = string.Empty;
    }


    ///<summary>
    ///  A set of ordered Quantity values defined by a low and high limit. 
    ///  A Range specifies a set of possible values; usually, one value from the range applies (e.g. "give the patient between 2 and 4 tablets"). Ranges are typically used in instructions. 
    ///</summary>
    public class Range
    {
        ///$Low limit Refer to: Structure: Quantity/v1
        public Quantity Low { get; } = new Quantity();
        ///$High limit Refer to: Structure: Quantity/v1
        public Quantity High { get; } = new Quantity();
        ///Id of range (Temporary field)
        public String Id { get; } = string.Empty;
    }


    ///<summary>
    ///  A relationship between two Quantity values expressed as a numerator and a denominator. 
    /// The Ratio datatype should only be used to express a relationship of two numbers if the relationship cannot be suitably expressed using a Quantity and a common unit. Where the denominator value is known to be fixed to "1", Quantity should be used instead of Ratio. 
    ///</summary>
    public class Ratio
    {
        ///$Numerator value Refer to: Structure: Quantity/v1
        public Quantity Numerator { get; } = new Quantity();
        ///$Denominator value Refer to: Structure: Quantity/v1
        public Quantity Denominator { get; } = new Quantity();
        ///Id of the Ratio (Temporary field)
        public String Id { get; } = string.Empty;
    }


    ///<summary>
    ///  A set of rules that describe when the event is scheduled.
    ///</summary>
    public class Repeat
    {
        ///$Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
        /// Refer to: Structure[]: Duration/v1
        public Duration[] Bounds { get; } = new Duration[0];
        ///A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
        /// If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.
        public uint Count { get; } = 0;
        ///If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
        public uint CountMax { get; } = 0;
        ///How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
        ///For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).
        public Decimal Duration { get; } = Decimal.Zero;
        ///If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
        ///For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).
        public Decimal DurationMax { get; } = Decimal.Zero;
        ///$The units of time for the duration, in UCUM units. Refer to: Enum: UnitsOfTime/v1
        public UnitsOfTime DurationUnit { get; } = UnitsOfTime.H;
        ///The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
        public uint Frequency { get; } = 0;
        ///If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
        public uint FrequencyMax { get; } = 0;
        ///Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
        public Decimal Period { get; } = Decimal.Zero;
        ///If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
        public Decimal PeriodMax { get; } = Decimal.Zero;
        ///$The units of time for the period in UCUM units.
        public UnitsOfTime PeriodUnit { get; } = UnitsOfTime.H;
        ///$If one or more days of week is provided, then the action happens only on the specified day(s).
        ///If no days are specified, the action is assumed to happen every day as otherwise specified. The elements frequency and period cannot be used as well as dayOfWeek. Refer to: Enum[]: / WeekDay / v1
        public WeekDay[] DayOfWeek { get; } = new WeekDay[0];
        ///(Time type not supported by codegen) The specified time of day for action to take place.
        ///When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. The elements when, frequency and period cannot be used as well as timeOfDay.
        public DateTime[] TimeOfDay { get; } = new DateTime[0];
        ///$An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.
        ///When more than one event is listed, the event is tied to the union of the specified events. Refer to: Enum[]: EventTiming / v1
        ///EventTiming[] WhenTiming { get; };
        ///The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
        public uint Offset { get; } = 0;
    }

    ///<summary>
    ///  Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
    /// Describes the occurrence of an event that may occur multiple times. Timing schedules are used for specifying when events are expected or requested to occur, and may also be used to represent the summary of a past or ongoing event. For simplicity, the definitions of Timing components are expressed as 'future' events, but such components can also be used to describe historic or ongoing events.
    /// A Timing schedule can be a list of events and/or criteria for when the event happens, which can be expressed in a structured form and/or as a code. When both event and a repeating specification are provided, the list of events should be understood as an interpretation of the information in the repeat structure.
    ///</summary>
    public class Timing
    {
        ///Identifies specific times when the event occurs. (Note. due to codegen limitations, single event per timing was set) 
        public DateTime Event { get; } = DateTime.MinValue;
        ///$A set of rules that describe when the event is scheduled. Refer to: Structure: Repeat/v1
        public Repeat Repeat { get; } = new Repeat();
        ///$A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
        /// BID etc.are defined as 'at institutionally specified times'. For example, an institution may choose that BID is "always at 7am and 6pm". If it is inappropriate for this choice to be made, the code BID should not be used.Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times). Refer to: Enum: TimingAbbreviation/v1
        public TimingAbbreviation Code { get; } = TimingAbbreviation.AM;
    }


    ///<summary>
    ///  Value union which can provide different type of measured value.
    ///</summary>
    public class Value
    {
        ///$Value as quantity. Refer to: Structure: Quantity/v1
        public Quantity ValueQuantity { get; } = new Quantity();
        ///$Value as range of quantities. Refer to: Structure: Range/v1
        public Range ValueRange { get; } = new Range();
        ///$Value as ratio. Refer to: Structure: Ratio/v1
        public Ratio ValueRatio { get; } = new Ratio();
        ///$Value as time period. Refer to: Structure: Period/v1
        public Period ValuePeriod { get; } = new Period();
        ///Value as text.
        public String ValueString { get; } = string.Empty;
        ///Value as boolean true/false.
        public Boolean ValueBoolean { get; } = false;
        ///Id of the Value (Temporary field)
        public String Id { get; } = string.Empty;
    }

    ///<summary>
    ///  Addresses for people and organizations.
    ///</summary>
    public class Address
    {
        ///A new description
        public String StreetAddress { get; } = string.Empty;
        ///
        public String City { get; } = string.Empty;
        ///
        public String Country { get; } = string.Empty;
        ///
        public String ZipOrPostalCode { get; } = string.Empty;
    }


    ///<summary>
    ///  
    ///</summary>
    public class Organization
    {
        /// orgnization id
        public String OrganizationId { get; } = string.Empty;
        /// name
        public String Name { get; } = string.Empty;
        /// description
        public String Description { get; } = string.Empty;
        ///$Valid addresses used by the organization Refer to: Structure[]: Address/v1
        public Address[] Addresses { get; } = new Address[0];
    }

    ///<summary>
    ///  
    ///</summary>
    public class Person
    {
        /// person id 
        public String Id { get; } = string.Empty;
        /// last time
        public String LastName { get; } = string.Empty;
        /// first time
        public String FirstName { get; } = string.Empty;
        /// email address
        public String Email { get; } = string.Empty;
        /// department
        public String Department { get; } = string.Empty;
        /// phone number
        public String Phone { get; } = string.Empty;
        ///The organization employing the individual (optional)
        public String OrganizationId { get; } = string.Empty;
        /// address of the person, refer to: Address
        public Address[] Addresses { get; } = new Address[0];
    }


    ///<summary>
    ///  Component of template. Component can contain clause or other template.
    ///</summary>
    public class ClauseSpec
    {
        ///Reference to actual clause from catalog.
        public string Reference { get; } = string.Empty;
    }


    ///<summary>
    ///  Component of template. Component can contain clause or other template.
    ///</summary>
    public class TemplateSpec
    {
        ///Guid
        public String Id { get; } = string.Empty;
        ///Reference to actual template or clause from catalog.
        public Template Reference { get; } = new Template();
        ///List of components template build from.
        public Component[] Components { get; } = new Component[0];
    }
}


