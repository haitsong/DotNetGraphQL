using GraphQL.Types;

namespace DotNetGraphQL.API
{
    ///<summary>
    ///   Contact information for object support.
    ///</summary>
    public class ContactGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Contact>
    {
        public ContactGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of organization or person. Refer to: Structure: /Identity");
            Field(x => x.URL).Description(@"The URL pointing to the contact information.");
            Field(x => x.EMail).Description(@"The email address of the contact person/organization.");
        }
    }


    ///<summary>
    ///   Entity encapsulating the details of an error. This allows the recipient to know details about the error and what may have caused the error.

    ///</summary>
    public class ErrorGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Error>
    {
        public ErrorGraphType()
        {
            Field(x => x.Code).Description(@"Error code. ");
            Field<SeverityEnum>("Severity", resolve: x => x.Source.Severity, description: @"$Severity specified how severe error in current execution path.  Refer to: Enum: /Severity/v1");
            Field(x => x.Text).Description(@"Error text. When error return text will be formate, based on text string, properties and language.");
            Field(x => x.Description).Description(@"Error description contains detailed information about error. ");
            Field<ListGraphType<PropertyGraphType>>("Properties", resolve: x => x.Source.Properties, description: @"$Properties allow to parametrize error name. Name can use @number or @name specification to reference different parameters from parameter list by ordinal number or by parameter name. Refer to: Structure[]: /Property/v1");
            Field(x => x.Entity).Description(@"URI to object or entity error associated with.");
            Field(x => x.Field).Description(@"Name of the field error associated with.");
        }
    }


    ///<summary>
    ///   Structure for object history. Object history provides information when object was updated and in what completion state it is now.
    ///</summary>
    public class HistoryGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.History>
    {
        public HistoryGraphType()
        {
            Field(x => x.CreatedAt).Description(@"Date of object creation.");
            Field(x => x.CreatedBy).Description(@"User created object.");
            Field(x => x.UpdatedAt).Description(@"Date of object last update. This is important value as it is flag for optimistic commit to detect overriding changes. ");
            Field(x => x.UpdatedBy).Description(@"User last updated object.");
            Field(x => x.UpdatedNote).Description(@"Mote about goal of object update.");
            Field(x => x.UpdatedMessage).Description(@"Message in issue associated with changes in object.");
            Field(x => x.ReviewedAt).Description(@"Date object last update was reviewed by owner. This is indicates user see and aknowalage change.");
            Field(x => x.ReviewedBy).Description(@"User who reviewed and acknowledge the last update changes.");
            Field(x => x.RetiredAt).Description(@"Date object was retired.");
            Field(x => x.RetiredBy).Description(@"User retired object.");
            Field<ListGraphType<CompletionGraphType>>("Completions", resolve: x => x.Source.Completions, description: @"$Array of completion statuses reached by this object. Refer to: Structure[]: Completion/v1");
        }
    }


    ///<summary>
    ///   Identity of object in DifHub. Objects can be identify by globaly unique Id and localy unique name.
    ///</summary>
    public class IdentityGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Identity>
    {
        public IdentityGraphType()
        {
            Field(x => x.Id).Description(@"Id of the object. It is global unique identificator, optional for minor objects and required for major objects. When object created Id will be generated by backend service.");
            Field(x => x.Name).Description(@"Name of the object. It is textual object identificator, need to be unique inside folder of the object.");
            Field(x => x.Description).Description(@"Description for the object functionality. It is text with specification of object and way it used in application.");
            Field<ListGraphType<TranslationGraphType>>("Translations", resolve: x => x.Source.Translations, description: @"$Translations for the object name, description to different languages. Object can contains as many translations as required by application. Refer to: Structure[]: /Translation/v1");
        }
    }

    ///<summary>
    ///   Property of object. Property presented as Name/Value pair.
    ///</summary>
    public class PropertyGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Property>
    {
        public PropertyGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of the property. Refer to: Structure: /Identity");
            Field(x => x.Type).Description(@"$Type of the property data. Refer to: Enum: /Type");
            Field(x => x.Reference).Description(@"Reference to structure for types of structure, field or enum. Reference can be complete and include organization name, system name, application name and dataset name. Reference can be short and contain only dataset name. Version identify structure currently used and if not specified, it means last approved version.");
            Field(x => x.Value).Description(@"Property value.");
        }
    }


    ///<summary>
    ///   Schedule for activity base on cron expression.
    ///</summary>
    public class ScheduleGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Schedule>
    {
        public ScheduleGraphType()
        {
            Field(x => x.Expression).Description(@"Cron expression to define time of execution. Expression represent text specification for execution time. ");
            Field<ListGraphType<TimeSpecGraphType>>("Specifications", resolve: x => x.Source.Specifications, description: @"$Specifications for points in time of execution. Refer to: Structure[]: /TimeSpec/v1");
        }
    }


    ///<summary>
    ///   Factor for time specification. Factor apply to current time components before compare with specification. For example for day 05/09/2017 is a day 9 of May. With factor 2 for Daily, we will divide it to 2 and compare remains to Month Day spec. If our spec defines execute on first day of month, and factor is 2, we will execute every second day of month.
    ///</summary>
    public class TimeFactorGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.TimeFactor>
    {
        public TimeFactorGraphType()
        {
            Field<FrequencyEnum>("Component", resolve: x => x.Source.Component, description: @"$Component of date factor apply to. Refer to: Enum: /Frequency/v1");
            Field(x => x.Value).Description(@"Value of factor to apply.");
        }
    }


    ///<summary>
    ///   Time specification defines reacquiring point in time, when some operation can be executed. Time spec validated against date-time of some moment in time. If moment match specification operation can be executed. Validation happens per every component of specification. Factor applied to component before validation. 
    ///For example: 
    ///1.Month - 05 means we execute in first hour of first day of May.
    ///2. Hour 00 means we execute on first hour of every day.
    ///3.Minute 3 means we execute every third minutes of the hour
    ///4. Hour 01, Minute 01 - we execute every day in first hour and first minute.
    ///</summary>
    public class TimeSpecGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.TimeSpec>
    {
        public TimeSpecGraphType()
        {
            Field<MonthEnum>("Month", resolve: x => x.Source.Month, description: @"$Specification of month in which bill need to be produced. Refer to: Enum: /Month/v1");
            Field<WeekEnum>("Week", resolve: x => x.Source.Week, description: @"$Specification for week. Refer to: Enum: /Week/v1");
            Field<MonthDayEnum>("Day", resolve: x => x.Source.Day, description: @"$Specification for month day bill need to be produced. Refer to: Enum: /MonthDay/v1");
            Field<WeekDayEnum>("WeekDay", resolve: x => x.Source.WeekDay, description: @"$Specification for week day on which bill need to be produced. Refer to: Enum: /WeekDay/v1");
            Field<HourEnum>("Hour", resolve: x => x.Source.Hour, description: @"$Specification cat off time of day for bill production. Refer to: Enum: /Hour/v1");
            Field(x => x.Minute).Description(@"Minute we use to execute. It is number from 0 to 50.");
            Field<ListGraphType<TimeFactorGraphType>>("Factors", resolve: x => x.Source.Factors, description: @"$This is factors used to modify portion of current date for validation with spec.   Refer to: Structure[]: /TimeFactor/v1");
        }
    }


    ///<summary>
    ///   Translation for object identity to specific language. Translation can contains information for value of object specific to language it represents.
    ///</summary>
    public class TranslationGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Translation>
    {
        public TranslationGraphType()
        {
            Field<LocaleEnum>("Locale", resolve: x => x.Source.Locale, description: @"$Locale for language translation defined for. Refer to: Enum: /Locale/v1");
            Field(x => x.Name).Description(@"Translation for object name.");
            Field(x => x.Description).Description(@"Translation for object description.");
            Field(x => x.Value).Description(@"Value specific to translation locale for objects with value.");
        }
    }


    ///<summary>
    ///   Structure to maintain value of specific type.
    ///</summary>
    public class VariantGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Variant>
    {
        public VariantGraphType()
        {
            Field(x => x.Value).Description(@"Value of type variant maintained.");
        }
    }


    ///<summary>
    ///   Object version. Version presented by 3 values: Major present backward incompatable versions, Minor identify backward compatable version and Revision identified small fixes.
    ///</summary>
    public class VersionGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Version>
    {
        public VersionGraphType()
        {
            Field(x => x.Major).Description(@"Major version of object. Major version introduced for not backward compatabale changes. New major version of an object can be created only for latest object version.");
            Field(x => x.Minor).Description(@"Minor version of object. Minor version introduce for backward compatable changes. New minor version of an object can be created only for latest object version.");
            Field(x => x.Revision).Description(@"Object revision. Introduced for bag fixes with backward compatability garantee. Revision can be created for any version of the object.");
            Field(x => x.Label).Description(@"Version label. Human friendly label for the version. Label need to be unique for all object versions.");
        }
    }

    ///<summary>
    ///   Agreement is a container for all agreement documents.
    ///</summary>
    public class AgreementGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Agreement>
    {
        public AgreementGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of documents contain globally unique id. Refer to: Structure: /Identity/v1");
            Field<EntityGraphType>("Entity", resolve: x => x.Source.Entity, description: @"$Document is a resource and will be accessible through API. Refer to: Structure: Entity/v1");
            Field<ListGraphType<AgreementPartyGraphType>>("Parties", resolve: x => x.Source.Parties, description: @"$Parties participating in agreement. Refer to: Structure[]: AgreementParty/v1");
        }
    }


    ///<summary>
    ///   Contact of agreement Party. Contact reference to party contact by type or id.
    ///</summary>
    public class AgreementContactGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.AgreementContact>
    {
        public AgreementContactGraphType()
        {
            Field(x => x.Id).Description(@"Identity of agreement party contact must be unique inside agreement. party");
            Field<ElementGraphType>("Header", resolve: x => x.Source.Header, description: @"$Management information for object. Refer to: Structure: Element/v1");
            Field<ContactRoleEnum>("Role", resolve: x => x.Source.Role, description: @"$Role of contact in agreement. Refer to: Enum: ContactRole/v1");
            Field<ContactTypeEnum>("Type", resolve: x => x.Source.Type, description: @"$Type of contact from list of contact of the party. Refer to: Enum: ContactType/v1");
            Field(x => x.ContactId).Description(@"Id of the contact in the list of party contacts. This is optional if specific contact assigned to role in agreement.");
        }
    }


    ///<summary>
    ///   Party of agreement. Party is reference to party resource.
    ///</summary>
    public class AgreementPartyGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.AgreementParty>
    {
        public AgreementPartyGraphType()
        {
            Field(x => x.Id).Description(@"Identity of agreement party must be unique inside agreement.");
            Field<ElementGraphType>("Header", resolve: x => x.Source.Header, description: @"$Management information for action Refer to: Structure: Element/v1");
            Field(x => x.Role).Description(@"Role of the party in agreement. Roles defined by agreement creator. Role must be unique for party inside agreement.");
            Field(x => x.Party).Description(@"Party to reference for agreement participation.");
            Field<ListGraphType<AgreementContactGraphType>>("Contacts", resolve: x => x.Source.Contacts, description: @"$List of contacts to work on party agreement. Refer to: Structure[]: AgreementContact/v1");
        }
    }

    ///<summary>
    ///   Document of agreement. Document build on top of template by providing required configuration properties. Data can be specified on level of clauses or on level of template.
    ///</summary>
    public class DocumentGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Document>
    {
        public DocumentGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of documents contain globally unique id. Refer to: Structure: /Identity/v1");
            Field<EntityGraphType>("Entity", resolve: x => x.Source.Entity, description: @"$Document is a resource and will be accessible through API. Refer to: Structure: Entity/v1");
            Field<VersionGraphType>("Version", resolve: x => x.Source.Version, description: @"$Document will have versions, as it will be evolving. Refer to: Structure: /Version/v1");
            Field(x => x.Parties).Description(@"List of parties participating in document from list of parties of agreement, Here is refereence by role of the party in agreement.");
            Field<ListGraphType<ComponentGraphType>>("Components", resolve: x => x.Source.Components, description: @"$List of components document assembled from.  Refer to: Structure[]: Component/v1");
            Field(x => x.Id).Description(@"Document id in list of documents");
            Field<ElementGraphType>("Header", resolve: x => x.Source.Header, description: @"$Management information for document Refer to: Structure: Element/v1");
            Field(x => x.DocumentType).Description(@"Educational material document identifier");
            Field(x => x.Reference).Description(@"Educational material reference pointer");
            Field(x => x.PublicationDate).Description(@"Educational material publication date");

            Field(x => x.DocumentId).Description(@"Identifier for the document across versions. The Id of each document version differs for each version. The documentID remains the same for each version.");
            Field(x => x.TemplateId).Description(@"The template used to create the document.");
            Field(x => x.Name).Description(@"name of the document");
            Field(x => x.Dataset).Description(@"The complete json data set that, with the template, populates the document contents.");
            Field(x => x.CreatedDate).Description(@"created at date");
            Field(x => x.CreatedById).Description(@"created by person id");
            Field(x => x.LastUpdatedById).Description(@"last update by person id");
        }
    }

    ///<summary>
    ///   Party represents partner account. Agreement can be created between multiple external parties and organizations of current account.
    ///</summary>
    public class PartyGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Party>
    {
        public PartyGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of parties contain globally unique id. Refer to: Structure: /Identity/v1");
            Field<EntityGraphType>("Entity", resolve: x => x.Source.Entity, description: @"$Party is a resource and will be accessible through API. Refer to: Structure: Entity/v1");
            Field<ListGraphType<ContactGraphType>>("Contacts", resolve: x => x.Source.Contacts, description: @"$List of contacts used for party. Refer to: Structure[]: Contact/v1");
        }
    }


    ///<summary>
    ///   Attribute of the schema
    ///</summary>
    public class AttributeGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Attribute>
    {
        public AttributeGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of the attribute. Refer to: Structure: /Identity");
            Field(x => x.Ordinal).Description(@"Position of attribute  in the list. ");
            Field(x => x.Count).Description(@"Number of value for attribute. By default it is one, it means attribute is single value. When count set to 0, it is array of values of undefined size. All other numbers defines fixed size for array.");
            Field(x => x.Type).Description(@"$Type of attributes. Let's use system types for now. Refer to: Enum: /Type/v1");
            Field<ClauseSchemaGraphType>("Reference", resolve: x => x.Source.Reference, description: @"Reference is URI of other schema.");
            Field(x => x.Default).Description(@"Default value for attribute.");
            Field(x => x.Format).Description(@"Format for attribute value. Default value must be presented in specified format.");
        }
    }


    ///<summary>
    ///   Specification of clause component in catalog. Clause contains specification for schema and rendering.
    ///</summary>
    public class ClauseGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Clause>
    {
        public ClauseGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Clause have globally unique id. Refer to: Structure: /Identity/v1");
            Field<VersionGraphType>("Version", resolve: x => x.Source.Version, description: @"$Clause will have versions, as it will be evolving. Refer to: Structure: /Version/v1");
            Field<EntityGraphType>("Entity", resolve: x => x.Source.Entity, description: @"$Clause is a resource and will be accessible through API.  Refer to: Structure: Entity/v1");
            Field(x => x.Parties).Description(@"List of parties recognized by clause. Party presented by name. Name of party used to identify party obligations.");
            Field<ListGraphType<AttributeGraphType>>("Attributes", resolve: x => x.Source.Attributes, description: @"$Clause list of attributes, which defines clause schema. Refer to: Structure[]: Attribute/v1");
            Field<ListGraphType<EventGraphType>>("Events", resolve: x => x.Source.Events, description: @"$List of events supported by clause. Refer to: Structure[]: Event/v1");
        }
    }


    ///<summary>
    ///   Obligation for one of clause's party. Obligation will be activated on event and provide information associated with it. 
    ///</summary>
    public class ClauseObligationGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.ClauseObligation>
    {
        public ClauseObligationGraphType()
        {
            Field(x => x.Id).Description(@"Identity of obligation inside clause event..");
            Field<ElementGraphType>("Header", resolve: x => x.Source.Header, description: @"$Management information for clause obligation Refer to: Structure: Element/v1");
            Field(x => x.Party).Description(@"Name of clause party associated with obligation.");
            Field<ObligationGraphType>("Obligations", resolve: x => x.Source.Obligations, description: @"Reference to obligation defined in catalog.");
        }
    }


    ///<summary>
    ///   View Element. Element represent visual component of view.
    ///</summary>
    public class ElementGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Element>
    {
        public ElementGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of view element. Refer to: Structure: /Identity/v1");
            Field(x => x.Order).Description(@"Order define position for element in view. Elements can have different order from sequence of specification. If order define as 0 it same as sequence number of specification.");
            Field<IdentityGraphType>("Parent", resolve: x => x.Source.Parent, description: @"Reference to parent element. Parent define frame this element included in.");
            Field<EventTypeEnum>("Visibility", resolve: x => x.Source.Visibility, description: @"$Visability property defines if it visual or hidden. Refer to: Enum: EventType/v1");
            Field<ClauseGraphType>("Frame", resolve: x => x.Source.Frame, description: @"$Frame of element. Frame define rectangular view for element visual components. Refer to: Structure: Clause/v1");
            Field<ClauseGraphType>("Style", resolve: x => x.Source.Style, description: @"$Style of element. Style define attributes of element visual components. Refer to: Structure: Clause/v1");
            Field<AttributeGraphType>("Image", resolve: x => x.Source.Image, description: @"$Image of element visual component. Refer to: Structure: Attribute/v1");
            Field(x => x.Text).Description(@"Text of element visual component.");
            Field<EventTypeEnum>("Align", resolve: x => x.Source.Align, description: @"$Alignment of text in element content frame. Refer to: Enum: EventType/v1");
            Field<ClauseGraphType>("Control", resolve: x => x.Source.Control, description: @"$Control of element. Control define configuration for visual compoments. Refer to: Structure: Clause/v1");
            //todo: Field<PeriodGraphType>("Period", resolve: x => x.Source.Period, description: @"$Time period element apply to. If period not close, it is current element. If period closed, it is element relevant for this period. Refer to: Structure: Period/v1");
        }
    }


    ///<summary>
    ///   Event of the clause. Clause fire events when state controlled by clause changed.
    ///</summary>
    public class EventGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Event>
    {
        public EventGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of the event. Refer to: Structure: /Identity");
            Field(x => x.Ordinal).Description(@"Position of event in the list of events ");
            Field<EventTypeEnum>("Type", resolve: x => x.Source.Type, description: @"$Type of event Refer to: Enum: EventType/v1");
            Field<ListGraphType<AttributeGraphType>>("Attributes", resolve: x => x.Source.Attributes, description: @"$Event list of attributes. This is attributes event will provide when fired. Refer to: Structure[]: Attribute/v1");
            Field<ListGraphType<ClauseObligationGraphType>>("Obligations", resolve: x => x.Source.Obligations, description: @"$List of obligations activated by event. Refer to: Structure[]: ClauseObligation/v1");
        }
    }


    ///<summary>
    ///   Obligation defined by clause. Obligation will be fired when event associated with it fired up.
    ///</summary>
    public class ObligationGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Obligation>
    {
        public ObligationGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Obligation have globally unique id. Refer to: Structure: /Identity/v1");
            Field<VersionGraphType>("Version", resolve: x => x.Source.Version, description: @"$Clause will have versions, as it will be evolving. Refer to: Structure: /Version/v1");
            Field<EntityGraphType>("Entity", resolve: x => x.Source.Entity, description: @"$Schema is a resource and will be accessible through API.  Refer to: Structure: Entity/v1");
            Field<ListGraphType<AttributeGraphType>>("Attributes", resolve: x => x.Source.Attributes, description: @"$Attributes of the schema Refer to: Structure[]: Attribute/v1");
        }
    }


    ///<summary>
    ///   Schema for the clause data.
    ///</summary>
    public class ClauseSchemaGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.ClauseSchema>
    {
        public ClauseSchemaGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Shema have globally unique id. Refer to: Structure: /Identity/v1");
            Field<VersionGraphType>("Version", resolve: x => x.Source.Version, description: @"$Clause will have versions, as it will be evolving. Refer to: Structure: /Version/v1");
            Field<EntityGraphType>("Entity", resolve: x => x.Source.Entity, description: @"$Schema is a resource and will be accessible through API.  Refer to: Structure: Entity/v1");
            Field<ListGraphType<AttributeGraphType>>("Attributes", resolve: x => x.Source.Attributes, description: @"$Attributes of the schema Refer to: Structure[]: Attribute/v1");
        }
    }


    ///<summary>
    ///   Event of the clause. Clause fire events when state controlled by clause changed.
    ///</summary>
    public class ViewGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.View>
    {
        public ViewGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of the event. Refer to: Structure: /Identity");
            Field(x => x.Ordinal).Description(@"Position of event in the list of events ");
            Field<ViewTypeEnum>("Type", resolve: x => x.Source.Type, description: @"$Type of view. Refer to: Enum: ViewType/v1");
            Field<ViewFormEnum>("Form", resolve: x => x.Source.Form, description: @"$Form factor of view. Refer to: Enum: ViewForm/v1");
            Field<LocaleEnum>("Language", resolve: x => x.Source.Language, description: @"$Type of event Refer to: Enum: /Locale/v1");
            Field<ListGraphType<ElementGraphType>>("Elements", resolve: x => x.Source.Elements, description: @"$View's list of elements. Elements define actual visual components of the view. Refer to: Structure[]: Element/v1");
        }
    }


    ///<summary>
    ///   Component of template. Component can contain clause or other template.
    ///</summary>
    public class ActionGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Action>
    {
        public ActionGraphType()
        {
            Field(x => x.Id).Description(@"Identity of action must be unique inside template.");
            Field<ElementGraphType>("Header", resolve: x => x.Source.Header, description: @"$Management information for action Refer to: Structure: Element/v1");
            Field(x => x.Component).Description(@"Component id in the template action defined for.");
            Field(x => x.Event).Description(@"Event id in the component action defined for.");
            Field(x => x.Obligation).Description(@"Obligation action to support.");
            Field(x => x.Workflow).Description(@"Workflow to execute for obligation support.");
        }
    }


    ///<summary>
    ///   Component of template. Component can contain clause or other template.
    ///</summary>
    public class ComponentGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Component>
    {
        public ComponentGraphType()
        {
            Field(x => x.Id).Description(@"Identity of component must be unique inside template.");
            Field<ElementGraphType>("Header", resolve: x => x.Source.Header, description: @"$Management information for component Refer to: Structure: Element/v1");
            Field<ComponentTypeEnum>("Type", resolve: x => x.Source.Type, description: @"$Type of component defines it use clause or other template. Refer to: Enum: ComponentType/v1");
            Field<ListGraphType<ComponentPartyGraphType>>("Parties", resolve: x => x.Source.Parties, description: @"$List of parties used in component. Refer to: Structure[]: ComponentParty/v1");
            Field<ComponentSpecGraphType>("Specification", resolve: x => x.Source.Specification, description: @"$Reference to actual template or clause from catalog. Refer to: Structure: ComponentSpec/v1");
            Field(x => x.Dataset).Description(@"Specification of values for clause or template attributes. Reference  to attributes of current template attributes can be used to configure clause or template.");
        }
    }


    ///<summary>
    ///   Party of component of template. Party map template and document party to parties of clause or template in component..
    ///</summary>
    public class ComponentPartyGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.ComponentParty>
    {
        public ComponentPartyGraphType()
        {
            Field(x => x.Id).Description(@"Name of clause or template party inside component. This is party name specified in actual clause or template reference by component. ");
            Field<ElementGraphType>("Header", resolve: x => x.Source.Header, description: @"$Management information for component party. Refer to: Structure: Element/v1");
            Field(x => x.Party).Description(@"Reference to actual party of template or document by name of the party/.");
            Field(x => x.Dataset).Description(@"Specification of values for the party as it presented in component on time of document creation..");
        }
    }


    ///<summary>
    ///   Component of template. Component can contain clause or other template.
    ///</summary>
    public class ComponentSpecGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.ComponentSpec>
    {
        public ComponentSpecGraphType()
        {
            Field<ListGraphType<ClauseSpecGraphType>>("Clauses", resolve: x => x.Source.Clauses, description: @"Reference to actual clause from clause catalog.");
            Field<TemplateSpecGraphType>("Template", resolve: x => x.Source.Template, description: @"Reference to actual template from template catalog.");
        }
    }


    ///<summary>
    ///   Integration of template with enterprise internal and external systems. Template can have multiple integrations designed for different set of systems. When document created, integration relevant for party will be used.
    ///</summary>
    public class IntegrationGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Integration>
    {
        public IntegrationGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of integration contains globally unique id. Refer to: Structure: /Identity/v1");
            Field<VersionGraphType>("Version", resolve: x => x.Source.Version, description: @"$Integration will have versions, as it will be evolving. Refer to: Structure: /Version/v1");
            Field<EntityGraphType>("Entity", resolve: x => x.Source.Entity, description: @"$Integration is a resource and will be accessible through API. Parent for Integration is a Template.   Refer to: Structure: Entity/v1");
            Field(x => x.Party).Description(@"Party of template, integration is applicable for.");
            Field<ListGraphType<AttributeGraphType>>("Attributes", resolve: x => x.Source.Attributes, description: @"$List of attributes template required to specify for document. Refer to: Structure[]: Attribute/v1");
            Field<ListGraphType<ActionGraphType>>("Actions", resolve: x => x.Source.Actions, description: @"$List of actions implemented in template. Refer to: Structure[]: Action/v1");
        }
    }


    ///<summary>
    ///   Template of agreement. Template specified prototype for agreements. Agreement documents use template to configure actual agreement. Template contains two main parts: attributes and components. Attributes provide specification of configuration parameters for template. Components defines smart clauses document will be assembled from.
    ///</summary>
    public class TemplateGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Template>
    {
        public TemplateGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Identity of template contains globally unique id. Refer to: Structure: /Identity/v1");
            Field<VersionGraphType>("Version", resolve: x => x.Source.Version, description: @"$Template will have versions, as it will be evolving. Refer to: Structure: /Version/v1");
            Field<EntityGraphType>("Entity", resolve: x => x.Source.Entity, description: @"$Template is a resource and will be accessible through API.  Refer to: Structure: Entity/v1");
            Field(x => x.Parties).Description(@"List of parties recognized by template. Party presented by name. Name of party used to identify party connection to templates clauses..");
            Field<ListGraphType<AttributeGraphType>>("Attributes", resolve: x => x.Source.Attributes, description: @"$List of attributes template required to specify for document. Refer to: Structure[]: Attribute/v1");
            Field<ListGraphType<ComponentGraphType>>("Components", resolve: x => x.Source.Components, description: @"$List of components template assembled from.  Refer to: Structure[]: Component/v1");
        }
    }

    ///<summary>
    ///   A amount of money. Money meagered by sum of currency.
    ///</summary>
    public class AmountGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Amount>
    {
        public AmountGraphType()
        {
            Field(x => x.MoneyAmount).Description(@"Amount of money");
            Field<CurrencyEnum>("Currency", resolve: x => x.Source.Currency, description: @"$Currency to represent amount of money.  Refer to: Enum: /Currency/v1");
        }
    }


    ///<summary>
    ///   A text note which also contains information about who made the statement and when. http://build.fhir.org//datatypes.html#Attachment
    ///</summary>
    public class AnnotationGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Annotation>
    {
        public AnnotationGraphType()
        {
            Field(x => x.Id).Description(@"This is id for note element. ");
            Field<ElementGraphType>("Header", resolve: x => x.Source.Header, description: @"$This is header for note , containing information for record management. Refer to: Structure: Element/v1");
            Field<AuthorGraphType>("Author", resolve: x => x.Source.Author, description: @"$Individual responsible for the annotation Refer to: Structure: Author/v1");
            Field(x => x.Text).Description(@"The annotation - text content (as markdown)");
        }
    }


    ///<summary>
    ///   This type is for containing or referencing attachments - additional data content defined in other formats. The most common use of this type is to include images or reports in some report format such as PDF. However it can be used for any data that has a MIME type. http://build.fhir.org//datatypes.html#Attachment
    ///</summary>
    public class AttachmentGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Attachment>
    {
        public AttachmentGraphType()
        {
            Field(x => x.Id).Description(@"Guid of the attachmentt");
            Field(x => x.ContentType).Description(@"Mime type of the content, with charset etc.");
            Field<LocaleEnum>("Language", resolve: x => x.Source.Language, description: @"$Human language of the content (BCP-47) Refer to: Enum: /Locale/v1");
            Field(x => x.Data).Description(@"Data inline, base64ed");
            Field(x => x.Url).Description(@"Uri where the data can be found");
            Field(x => x.Size).Description(@"Number of bytes of content (if url provided)");
            Field(x => x.Hash).Description(@"Hash of the data (sha-1, base64ed)");
            Field(x => x.Title).Description(@"Label to display in place of the data");
            Field(x => x.Creation).Description(@"Date attachment was first created");
            Field<ElementGraphType>("ElementId", resolve: x => x.Source.ElementId, description: @"$This is id for period element. It is inherit properties from Element structure. Refer to: Structure: Element/v1");
        }
    }


    ///<summary>
    ///   Author union which can provide different type of author reference for document.
    ///</summary>
    public class AuthorGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Author>
    {
        public AuthorGraphType()
        {
            Field(x => x.AuthorReference).Description(@"Reference to author of the document registered in the system as entity.");
            Field(x => x.AuthorString).Description(@"Text information about author not reference in the system.");
        }
    }


    ///<summary>
    ///   Binding represents connection of entity to entity in other external systems. It can be system where entity actually originated ond from which it was imported or system where entity exported. 
    ///</summary>
    public class BindingGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Binding>
    {
        public BindingGraphType()
        {
            Field<IdentityGraphType>("Identity", resolve: x => x.Source.Identity, description: @"$Binding identity in system it imported from or exported to. Id is globally unique. Name is unique binding name inside entity only. Refer to: Structure: /Identity");
            Field<BindingTypeEnum>("Type", resolve: x => x.Source.Type, description: @"$Type of binding defines system we bind to. Refer to: Enum: BindingType/v1");
            Field(x => x.Code).Description(@"Code of object in system we bind to if different from id.");
        }
    }


    ///<summary>
    ///   Completion status for stage of execution like: finilization, aproval and so on.
    ///</summary>
    public class CompletionGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Completion>
    {
        public CompletionGraphType()
        {
            Field<EntityStateEnum>("Status", resolve: x => x.Source.Status, description: @"$Completion Status for some state of execution. Refer to: Enum: EntityState/v1");
            Field(x => x.CompletedAt).Description(@"Date of status acived and satge of activity completed.");
            Field(x => x.CompletedBy).Description(@"Person documented completion of this stage by user name.");
            Field(x => x.CompletedNote).Description(@"Note provided by operator on completion.");
            Field(x => x.CompletedMessage).Description(@"This is link to message, which change status of the issue to specified by this completion.");
        }
    }





    ///<summary>
    ///   Duration union which can provide different type of time duration values.
    ///</summary>
    public class DurationGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Duration>
    {
        public DurationGraphType()
        {
            Field(x => x.DurationTimespan).Description(@"Duration as time span.");
            Field<DurationSpecGraphType>("DurationTimeSpec", resolve: x => x.Source.DurationTimeSpec, description: @"$Duration as duration specification by units of time. Refer to: Structure: DurationSpec/v1");
            Field<PeriodGraphType>("DurationPeriod", resolve: x => x.Source.DurationPeriod, description: @"$Duration as period of time defined by specification Refer to: Structure: Period/v1");
            Field<PeriodSpecGraphType>("DurationPeriodSpec", resolve: x => x.Source.DurationPeriodSpec, description: @"$Duration as period of time. Refer to: Structure: PeriodSpec/v1");
            Field<RangeGraphType>("DurationRange", resolve: x => x.Source.DurationRange, description: @"$Range of values for duration. Refer to: Structure: Range/v1");
            Field(x => x.Id).Description(@"Id of Occurence");
        }
    }


    ///<summary>
    ///   A time period defined by number of time units. 

    ///</summary>
    public class DurationSpecGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.DurationSpec>
    {
        public DurationSpecGraphType()
        {
            Field(x => x.Value).Description(@"Number of time units used for period.");
            Field<UnitsOfTimeEnum>("Units", resolve: x => x.Source.Units, description: @"$Time units to define duration. Refer to: Enum: UnitsOfTime/v1");
        }
    }


    ///<summary>
    ///   Updatable entity. Entity can be accessed by RESTful API and referenced.
    ///</summary>
    public class EntityGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Entity>
    {
        public EntityGraphType()
        {
            Field<IdentityGraphType>("Parent", resolve: x => x.Source.Parent, description: @"$Reference to id of folder for current entity. It include URI of parent entity in name. Refer to: Structure: /Identity");
            Field<EntityTypeEnum>("Type", resolve: x => x.Source.Type, description: @"$Type of the entity. Refer to: Enum: EntityType/v1");
            Field<EntityStateEnum>("State", resolve: x => x.Source.State, description: @"$State of the entity Refer to: Enum: EntityState/v1");
            Field(x => x.Active).Description(@"This entity record is in active use");
            Field(x => x.Alias).Description(@"List of additional names for the entity.");
            Field<BindingTypeEnum>("Source", resolve: x => x.Source.Source, description: @"$Source system originated the entity. If not specified entity instantiated by core system. Refer to: Enum: BindingType/v1");
            Field<ListGraphType<BindingGraphType>>("Bindings", resolve: x => x.Source.Bindings, description: @"$Reference to entity system bind to. Refer to: Structure[]: Binding/v1");
            Field<ListGraphType<IdentityGraphType>>("Tags", resolve: x => x.Source.Tags, description: @"$List of tags for entity association. Refer to: Structure[]: /Identity/v1");
            Field<ListGraphType<PropertyGraphType>>("Properties", resolve: x => x.Source.Properties, description: @"$Advince properties of the entity. It is name value pairs for additional user defined properties of the entity. Refer to: Structure[]: /Property/v1");
            Field<HistoryGraphType>("History", resolve: x => x.Source.History, description: @"$History of the entity instance. Refer to: Structure: History/v1");
        }
    }


    ///<summary>
    ///   Link to a resource that associated with current resource.
    ///</summary>
    public class LinkGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Link>
    {
        public LinkGraphType()
        {
            Field<ElementGraphType>("ElementId", resolve: x => x.Source.ElementId, description: @"$Element data inherited from element structure Refer to: Structure: Element/v1");
            Field(x => x.Target).Description(@" The resource to which this resource is associated.");
            Field<LinkTypeEnum>("Type", resolve: x => x.Source.Type, description: @"$Type of the link. Refer to: Enum: LinkType/v1");
        }
    }


    ///<summary>
    ///   Occurrence union which can provide different type of time values.
    ///</summary>
    public class OccurrenceGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Occurrence>
    {
        public OccurrenceGraphType()
        {
            Field<PeriodGraphType>("OccurrencePeriod", resolve: x => x.Source.OccurrencePeriod, description: @"$occurrence as period of time. Refer to: Structure: Period/v1");
            Field<RangeGraphType>("OccuranceRange", resolve: x => x.Source.OccuranceRange, description: @"$Range of values for occurance. Refer to: Structure: Range/v1");
            Field(x => x.OccurrenceDateTime).Description(@"Occurrence as point in time.");
            Field<TimingGraphType>("OccurrenceTiming", resolve: x => x.Source.OccurrenceTiming, description: @"$Occurrence as point in time. Refer to: Structure: Timing/v1");
            Field(x => x.Id).Description(@"Id of Occurence");
        }
    }


    ///<summary>
    ///   A time period defined by a start and end date/time. 
    /// A period specifies a range of times. The context of use will specify whether the entire range applies (e.g. "the patient was an inpatient of the hospital for this time range") or one value from the period applies (e.g. "give to the patient between 2 and 4 pm on 24-Jun 2013"). This is simple period used not as part of array of elements.
    ///</summary>
    public class PeriodGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Period>
    {
        public PeriodGraphType()
        {
            Field(x => x.Start).Description(@"Starting time with inclusive boundary");
            Field(x => x.End).Description(@"End time with inclusive boundary, if not ongoing.");
        }
    }


    ///<summary>
    ///   Specification for time period. Specification used to define reacquiring period of time.
    ///</summary>
    public class PeriodSpecGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.PeriodSpec>
    {
        public PeriodSpecGraphType()
        {
            Field(x => x.YearStart).Description(@"First year of period specification.");
            Field(x => x.YearEnd).Description(@"Last year of specified period.");
            Field<MonthEnum>("MonthStart", resolve: x => x.Source.MonthStart, description: @"$First month of the period. Refer to: Enum: /Month/v1");
            Field<MonthEnum>("MonthEnd", resolve: x => x.Source.MonthEnd, description: @"$Last month of the period. Refer to: Enum: /Month/v1");
            Field<MonthDayEnum>("MonthDayStart", resolve: x => x.Source.MonthDayStart, description: @"$First day of month of the period. Refer to: Enum: /MonthDay/v1");
            Field<MonthDayEnum>("MonthDayEnd", resolve: x => x.Source.MonthDayEnd, description: @"$Last day of month of the period. Refer to: Enum: /MonthDay/v1");
            Field<WeekEnum>("WeekStart", resolve: x => x.Source.WeekStart, description: @"$First week of the period. Refer to: Enum: /Week/v1");
            Field<WeekEnum>("WeekEnd", resolve: x => x.Source.WeekEnd, description: @"$Last week of the period. Refer to: Enum: /Week/v1");
            Field<WeekDayEnum>("WeekDayStart", resolve: x => x.Source.WeekDayStart, description: @"$First day of week of the period. Refer to: Enum: /WeekDay/v1");
            Field<WeekDayEnum>("WeekDayEnd", resolve: x => x.Source.WeekDayEnd, description: @"$Last day of week of the period. Refer to: Enum: /WeekDay/v1");
            Field(x => x.TimeStart).Description(@"Initial time of time period.");
            Field(x => x.TimeEnd).Description(@"Final time of time period.");
        }
    }


    ///<summary>
    ///   The absolute geographic location.
    ///</summary>
    public class PositionGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Position>
    {
        public PositionGraphType()
        {
            Field(x => x.Longitude).Description(@"Longitude with WGS84 datum");
            Field(x => x.Altitude).Description(@"Latitude with WGS84 datum");
            Field(x => x.Latitude).Description(@"Altitude with WGS84 datum");
        }
    }


    ///<summary>
    ///   A amount of money to pay per quantity of service or product..
    ///</summary>
    public class PriceGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Price>
    {
        public PriceGraphType()
        {
            Field(x => x.Id).Description(@"Guid of the price");
            Field<AmountGraphType>("Amount", resolve: x => x.Source.Amount, description: @"$Amount of money to pay. Refer to: Structure: Amount/v1");
            Field<QuantityGraphType>("Quantity", resolve: x => x.Source.Quantity, description: @"$Quantity of service or product. By default it is one instance. Refer to: Structure: Quantity/v1");
        }
    }


    ///<summary>
    ///   A measured amount (or an amount that can potentially be measured). 
    ///</summary>
    public class QuantityGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Quantity>
    {
        public QuantityGraphType()
        {
            Field(x => x.Value).Description(@"Numerical value (with implicit precision)");
            Field<QuantityComparatorEnum>("Comparator", resolve: x => x.Source.Comparator, description: @"$How to understand the value Refer to: Enum: QuantityComparator/v1");
            Field(x => x.Unit).Description(@"Unit representation");
            Field(x => x.System).Description(@"System that defines coded unit form");
            Field(x => x.Code).Description(@"Coded form of the unit");
            Field(x => x.Id).Description(@"Id of the Quantity (Temporary field)");
        }
    }


    ///<summary>
    ///   A set of ordered Quantity values defined by a low and high limit. 
    /// A Range specifies a set of possible values; usually, one value from the range applies (e.g. "give the patient between 2 and 4 tablets"). Ranges are typically used in instructions. 
    ///</summary>
    public class RangeGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Range>
    {
        public RangeGraphType()
        {
            Field<QuantityGraphType>("Low", resolve: x => x.Source.Low, description: @"$Low limit Refer to: Structure: Quantity/v1");
            Field<QuantityGraphType>("High", resolve: x => x.Source.High, description: @"$High limit Refer to: Structure: Quantity/v1");
            Field(x => x.Id).Description(@"Id of range (Temporary field)");
        }
    }


    ///<summary>
    /// A relationship between two Quantity values expressed as a numerator and a denominator. 
    /// The Ratio datatype should only be used to express a relationship of two numbers if the relationship cannot be suitably expressed using a Quantity and a common unit. Where the denominator value is known to be fixed to "1", Quantity should be used instead of Ratio. 
    ///</summary>
    public class RatioGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Ratio>
    {
        public RatioGraphType()
        {
            Field<QuantityGraphType>("Numerator", resolve: x => x.Source.Numerator, description: @"$Numerator value Refer to: Structure: Quantity/v1");
            Field<QuantityGraphType>("Denominator", resolve: x => x.Source.Denominator, description: @"$Denominator value Refer to: Structure: Quantity/v1");
            Field(x => x.Id).Description(@"Id of the Ratio (Temporary field)");
        }
    }


    ///<summary>
    ///   A set of rules that describe when the event is scheduled.
    ///</summary>
    public class RepeatGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Repeat>
    {
        public RepeatGraphType()
        {
            Field<ListGraphType<DurationGraphType>>("Bounds", resolve: x => x.Source.Bounds, description: @"$Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule. Refer to: Structure[]: Duration/v1");
            Field(x => x.Count).Description(@"A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values. If you have both bounds and count, then this should be understood as within the bounds period, until count times happens.");
            Field(x => x.CountMax).Description(@"If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.");
            Field(x => x.Duration).Description(@"How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).");
            Field(x => x.DurationMax).Description(@"If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
For some events the duration is part of the definition of the event (e.g. IV infusions, where the duration is implicit in the specified quantity and rate). For others, it's part of the timing specification (e.g. exercise).");
            Field<UnitsOfTimeEnum>("DurationUnit", resolve: x => x.Source.DurationUnit, description: @"$The units of time for the duration, in UCUM units. Refer to: Enum: UnitsOfTime/v1");
            Field(x => x.Frequency).Description(@"The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.");
            Field(x => x.FrequencyMax).Description(@"If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.

");
            Field(x => x.Period).Description(@"Indicates the duration of time over which repetitions are to occur; e.g. to express /3 times per day/, 3 would be the frequency and /1 day/ would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length");
            Field(x => x.PeriodMax).Description(@"If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as /do this once every 3 - 5 days.");
            Field<UnitsOfTimeEnum>("PeriodUnit", resolve: x => x.Source.PeriodUnit, description: @"$The units of time for the period in UCUM units. Refer to: Enum: UnitsOfTime/v1");
            Field<ListGraphType<WeekDayEnum>>("DayOfWeek", resolve: x => x.Source.DayOfWeek, description: @"$If one or more days of week is provided, then the action happens only on the specified day(s). If no days are specified, the action is assumed to happen every day as otherwise specified. The elements frequency and period cannot be used as well as dayOfWeek. Refer to: Enum[]: /WeekDay/v1");
            Field(x => x.TimeOfDay).Description(@"(Time type not supported by codegen) The specified time of day for action to take place. When time of day is specified, it is inferred that the action happens every day (as filtered by dayofWeek) on the specified times. The elements when, frequency and period cannot be used as well as timeOfDay.");
            Field<ListGraphType<EventTimingEnum>>("WhenTiming", resolve: x => x.Source.WhenTiming, description: @"$An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.When more than one event is listed, the event is tied to the union of the specified events. Refer to: Enum[]: EventTiming/v1");
            Field(x => x.Offset).Description(@"The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.");
        }
    }


    ///<summary>
    ///   Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
    /// Describes the occurrence of an event that may occur multiple times. Timing schedules are used for specifying when events are expected or requested to occur, and may also be used to represent the summary of a past or ongoing event. For simplicity, the definitions of Timing components are expressed as 'future' events, but such components can also be used to describe historic or ongoing events.
    /// A Timing schedule can be a list of events and/or criteria for when the event happens, which can be expressed in a structured form and/or as a code. When both event and a repeating specification are provided, the list of events should be understood as an interpretation of the information in the repeat structure.
    ///</summary>
    public class TimingGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Timing>
    {
        public TimingGraphType()
        {
            Field(x => x.Event).Description(@"Identifies specific times when the event occurs. (Note. due to codegen limitations, single event per timing was set) ");
            Field<RepeatGraphType>("Repeat", resolve: x => x.Source.Repeat, description: @"$A set of rules that describe when the event is scheduled. Refer to: Structure: Repeat/v1");
            Field<TimingAbbreviationEnum>("Code", resolve: x => x.Source.Code, description: @"$A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
BID etc. are defined as 'at institutionally specified times'. For example, an institution may choose that BID is /always at 7am and 6pm/. If it is inappropriate for this choice to be made, the code BID should not be used. Instead, a distinct organization-specific code should be used in place of the HL7-defined BID code and/or a structured representation should be used (in this case, specifying the two event times). Refer to: Enum: TimingAbbreviation/v1");
        }
    }


    ///<summary>
    ///   Value union which can provide different type of measured value.
    ///</summary>
    public class ValueGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Value>
    {
        public ValueGraphType()
        {
            Field<QuantityGraphType>("ValueQuantity", resolve: x => x.Source.ValueQuantity, description: @"$Value as quantity. Refer to: Structure: Quantity/v1");
            Field<RangeGraphType>("ValueRange", resolve: x => x.Source.ValueRange, description: @"$Value as range of quantities. Refer to: Structure: Range/v1");
            Field<RatioGraphType>("ValueRatio", resolve: x => x.Source.ValueRatio, description: @"$Value as ratio. Refer to: Structure: Ratio/v1");
            Field<PeriodGraphType>("ValuePeriod", resolve: x => x.Source.ValuePeriod, description: @"$Value as time period. Refer to: Structure: Period/v1");
            Field(x => x.ValueString).Description(@"Value as text.");
            Field(x => x.ValueBoolean).Description(@"Value as boolean true/false.");
            Field(x => x.Id).Description(@"Id of the Value (Temporary field)");
        }
    }

    ///<summary>
    ///   Addresses for people and organizations.
    ///</summary>
    public class AddressGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Address>
    {
        public AddressGraphType()
        {
            Field(x => x.StreetAddress).Description(@"A new description");
            Field(x => x.City).Description(@"");
            Field(x => x.Country).Description(@"");
            Field(x => x.ZipOrPostalCode).Description(@"");
        }
    }


    ///<summary>
    ///   
    ///</summary>
    public class OrganizationGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Organization>
    {
        public OrganizationGraphType()
        {
            Field(x => x.OrganizationId).Description(@"");
            Field(x => x.Name).Description(@"");
            Field(x => x.Description).Description(@"");
            Field<ListGraphType<AddressGraphType>>("Addresses", resolve: x => x.Source.Addresses, description: @"$Valid addresses used by the organization Refer to: Structure[]: Address/v1");
        }
    }


    ///<summary>
    ///   
    ///</summary>
    public class PersonGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.Person>
    {
        public PersonGraphType()
        {
            Field(x => x.Id).Description(@"");
            Field(x => x.LastName).Description(@"");
            Field(x => x.FirstName).Description(@"");
            Field(x => x.Email).Description(@"");
            Field(x => x.Department).Description(@"");
            Field(x => x.Phone).Description(@"");
            Field(x => x.OrganizationId).Description(@"The organization employing the individual (optional)");
            Field<ListGraphType<AddressGraphType>>("Addresses", resolve: x => x.Source.Addresses, description: @"$ Refer to: Structure[]: Address/v1");
        }
    }

    ///<summary>
    ///   Component of template. Component can contain clause or other template.
    ///</summary>
    public class TemplateSpecGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.TemplateSpec>
    {
        public TemplateSpecGraphType()
        {
            Field(x => x.Id).Description(@"Guid");
            Field<TemplateGraphType>("Reference", resolve: x => x.Source.Reference, description:@"Reference to actual template or clause from catalog.");
            Field<ListGraphType<ComponentGraphType>>("Components", resolve: x => x.Source.Components, description:@"List of components template build from.");
        }
    }

    ///<summary>
    /// Component of template. Component can contain clause or other template.
    ///</summary>
    public class ClauseSpecGraphType : ObjectGraphType<DotNetGraphQL.Common.Models.ClauseSpec>
    {
        public ClauseSpecGraphType()
        {
            Field(x => x.Reference).Description(@"Reference to actual clause from catalog.");
        }
    }
}

